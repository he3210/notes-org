#+TITLE: golang 基础知识笔记
1. %T 打印变量类型
 =fmt.Printf("%T", d)=
2. 不同于 c 语言，Go 没有隐式类型转换，不同类型之间不能运算
3. 常量的值会在编译的时候确定，函数调用发生在运行时，所以不能将函数的返回值赋值给常量
 =const b = math.Sqrt(4)= 会报错
4. 声明一个无类型的常量后，可以把它赋值给类型兼容的变量
 #+BEGIN_SRC 
 const a = 5      // 无类型的常量
 const b int = 9  // 有类型的常量
 var b int = a
 var c int32 = a
 var d float64 = a
 var e complex64 = a
 #+END_SRC

5. 包的初始化顺序
   #+ATTR_ORG: :width 50%
   #+ATTR_HTML: :width 50%
   [[../images/package_order.png]]
  要注意的是，
    - 在 main.main 函数执行之前所有代码都运行在同一个 goroutine，也就是程序的主系统线程中。因此，如果某个 init 函数内部用 go 关键字启动了新的 goroutine 的话，新的 goroutine 只有在进入 main.main 函数之后才会开始执行
      #+BEGIN_SRC golang
        package main

        import (
           "fmt"
           "time"
        )

        var test = 1

        func init() {
           fmt.Println("enter into init")

           go func() {
              test = 2
              fmt.Println("hello world in goroute")
           }()

           fmt.Println("exit from init")
        }

        func main() {
            fmt.Println("1st test:",test)
            time.Sleep(1)
            fmt.Println("2nd test:",test)
        }
      #+END_SRC
      结果
      #+BEGIN_SRC shell
        enter into init
        exit from init
        1st test: 1
        2nd test: 1
      #+END_SRC

    - 每个包只会初始化一次。例如，即使 fmt 被多个包引入，也只会在第一次时被初始化
    - 包不能循环引用

6. 在 =${GOPATH}/src/= 目录下新建 go 项目 aa。然后执行 =go install aa= ，会在 =${GOPATH}/bin/= 目录下编译出 aa 的二进制文件
7. 循环语句没有 =while= 和 =do...while=
8. switch 语句中使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true
  #+BEGIN_SRC golang
    package main

    import (
        "fmt"
    )

    func number() int {
        return 40
    }

    func main() {
        switch num := number(); {
        case num < 20, num == 40:  // 任意满足一个条件就通过
            fmt.Printf("%d < 20 or %d == 40\n", num, num)
            fallthrough
        case num > 100:
            fmt.Printf("%d > 100\n", num)
        default:  // default 不一定放在 switch 语句最后
            fmt.Printf("default")
        case num < 70:
            fmt.Printf("%d < 200", num)
        }
    }
  #+END_SRC
  结果
  #+BEGIN_SRC shell
    40 < 20 or 40 == 40
    40 > 100
  #+END_SRC

9. 不同长度的数组不能相互赋值。例如 [3]int 的变量不能赋值给 [5]int
10. 数组是值类型不是引用类型。将数组 a 赋值给一个新的变量 b 后，对数组 b 的元素进行更改不影响数组 a；将数组作为形参传递给函数也是值传递
11. 切片是一个结构体，该结构体包含 len、cap 和指向数组的指针。当切片作为参数传递给函数时，会将该结构体值传递给函数
12. 可变参数函数
  #+BEGIN_SRC golang
    package main

    import (
        "fmt"
    )

    func change(s ...string) {
        s[0] = "Go"
        s = append(s, "playground")
        fmt.Println(s)
    }

    func main() {
        welcome := []string{"hello", "world"}
        change(welcome...)
        fmt.Println(welcome)
    }
  #+END_SRC
  结果
  #+BEGIN_SRC shell
    [Go world playground]
    [Go world]
  #+END_SRC
  + 可变参数 =s ...string= 会被转换为 =[]string= 类型切片然后在传入函数 change 中
  + 传入 =welcome...= 时，语法糖 =...= 代表不再转换为切片了，直接使用切片 =welcome=

13. make
  + 创建 len 为 3，cap 为 10 的切片 ~a := make([]string, 3, 10)~
  + 创建 map ~b := make(map[string]int)~

14. rune
  #+BEGIN_SRC golang
    runes := []rune("你好")
    for i:=0; i < len(runes); i++ {
        fmt.Printf("%c\n", runes[i])
    }
    s := "你好啊"
    for index, rune := range s {
        fmt.Printf("%c %d\n", rune, index)
    }
    fmt.Printf("len: %d, rune len: %d\n", len(s), utf8.RuneCountInString(s))
  #+END_SRC
  结果
  #+BEGIN_EXAMPLE
你
好
你 0
好 3
啊 6
len: 9, rune len: 3
  #+END_EXAMPLE

