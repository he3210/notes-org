#+TITLE: gdb 调试段错误

** 段错误产生原因

段错误是指非法访问内存产生的错误

*** 访问不存在的内存地址
#+BEGIN_SRC c
  #include<stdio.h> 
  #include<stdlib.h> 
  void main() 
  { 
      int *ptr = NULL; 
      *ptr = 0; 
  }
#+END_SRC

*** 访问系统保护的内存地址
#+BEGIN_SRC c
  #include<stdio.h> 
  #include<stdlib.h> 
  void main() 
  { 
      int *ptr = (int *)0; 
      *ptr = 100; 
  }
#+END_SRC

*** 访问只读的内存地址
#+BEGIN_SRC c
  #include<stdio.h> 
  #include<stdlib.h> 
  #include<string.h> 
  void main() 
  { 
      char *ptr = "test"; 
      strcpy(ptr, "TEST"); 
  }
#+END_SRC

*** 栈溢出
#+BEGIN_SRC c
  #include<stdio.h> 
  #include<stdlib.h> 
  void main() 
  { 
      main(); 
  }
#+END_SRC

** gdb 调试
*** 以栈溢出为例直接使用 gdb 调试
#+BEGIN_SRC bash
$ gcc segfault.c -g -o segfault
$ ./segfault
Segmentation fault (core dumped)
$ gdb segfault
...
(gdb) run	              # 使用 run 命令运行后，会提示段错误出现在文件中的位置，如下所示
Starting program: /home/he/Desktop/GDB/segfault

Program received signal SIGSEGV, Segmentation fault.
main () at segfault.c:5
5		main();
#+END_SRC

*** 使用 core 文件调试段错误
#+BEGIN_SRC bash
$ gcc segfault.c -g -o segfault
$ ulimit -c             # 显示 core 文件的大小
$ ulimit -c unlimited   # 把 core 文件设为最大，只对本次有效
$ ./segfault            # 运行程序生成 core 文件,设生成了 core.7963
Segmentation fault (core dumped)
$ gdb segfault core.7963
...
Core was generated by 'n./segfault'.
Program terminated with signal 11, Segmentation fault.
#0  main () at test2.c:12
12		main();
#+END_SRC
